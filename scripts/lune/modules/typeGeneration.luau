local typeGeneration = {}

local template = [[
/*
* This file was generated by Lune.
* Do not edit this file manually.
*/

interface %s extends %s {
    %s
}

]]

local functionTemplate = [[
%s(%s): %s;
]]

local indexTemplate = "%s: %s;"

local indexChildrenTemplate = [[
%s & {
    %s
}
]]

local limitRecursive = 10

function typeGeneration.parseIndex(className: string, classType: string)
    if string.find(className, "%W") then
        className = string.format("[\"%s\"]", className)
    end
    return string.format(indexTemplate, className, classType)
end

function typeGeneration.parseIndexChildren(className: string, classType: string, children: string)
    children = string.gsub(children, "\n", "\n    ")
    return string.format(indexChildrenTemplate, typeGeneration.parseIndex(className, classType):gsub(";",""), children)
end

function typeGeneration.parseFunction(name: string, args: string, returnType: string)
    return string.format(functionTemplate, name, args, returnType)
end

function typeGeneration.generateIndex(instance: Instance)
    local name = instance.Name
    local className = instance.ClassName

    return typeGeneration.parseIndex(name, className)
end

function typeGeneration.generateIndexChildren(instance: Instance, children: {string})
    local name = instance.Name
    local className = instance.ClassName

    return typeGeneration.parseIndexChildren(name, className, table.concat(children, "\n"))
end

function typeGeneration.generateFunction(name: string, args: string, returnType: string)
    return typeGeneration.parseFunction(name, args, returnType)
end

function typeGeneration.generateFunctions(functions: {string})
    return table.concat(functions, "\n")
end

function typeGeneration.generateInterface(name: string, parent: Instance, output: string)
    assert(parent == nil or parent:IsA("Instance"), "Parent must be an instance or nil!")

    local className = "Instance"
    local parentName = parent.Name

    output = string.gsub(output, "\n", "\n    ")
    return string.format(template, parentName, className, output)
end

function typeGeneration.generateInterfaceWithFunctions(name: string, parent: Instance, functions: {string})
    return typeGeneration.generateInterface(name, parent, typeGeneration.generateFunctions(functions))
end

function typeGeneration.internalGenerateInstancesTable(instance: Instance)
    local instances = {}

    for _, child in instance:GetChildren() do
        if instances[child.Name] then
            table.insert(instances[child.Name], child)
        else
            instances[child.Name] = {child}
        end
    end

    return instances
end

function typeGeneration.parseInstance(instance: Instance)
    local name = instance.Name
    
    local function parseRecursive(instance: Instance, limit: number)
        local children = {}
        local instances = typeGeneration.internalGenerateInstancesTable(instance)

        for name, child in instances do
            if limit > 0 then
                table.insert(children, parseRecursive(child[1], limit - 1))
            else
                table.insert(children, typeGeneration.generateIndex(child[1]))
            end
        end
        
        return #children > 0 and typeGeneration.generateIndexChildren(instance, children) or typeGeneration.generateIndex(instance)
    end

    return typeGeneration.generateInterface(name, instance.Parent or instance, parseRecursive(instance, limitRecursive))
end

return typeGeneration